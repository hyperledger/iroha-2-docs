import{_ as e,c as t,o as a,V as i}from"./chunks/framework.B6c1f-8R.js";const m=JSON.parse('{"title":"Public Key Cryptography","description":"","frontmatter":{},"headers":[],"relativePath":"guide/security/public-key-cryptography.md","filePath":"guide/security/public-key-cryptography.md","lastUpdated":1727363525000}'),r={name:"guide/security/public-key-cryptography.md"},n=i('<h1 id="public-key-cryptography" tabindex="-1">Public Key Cryptography <a class="header-anchor" href="#public-key-cryptography" aria-label="Permalink to &quot;Public Key Cryptography&quot;">​</a></h1><p>Public key cryptography provides the means for secure communication and data protection, enabling activities such as secure online transactions, encrypted email communications, etc.</p><p>Public key cryptography employs a pair of cryptographic keys—a <em>public</em> key and a <em>private</em> key—to create a highly secure method of transmitting information over online networks.</p><p>It&#39;s easy to make a public key from a private key, but the opposite is rather difficult, if not impossible. This keeps things safe. You can freely share your public key without risking your private key, which remains secure.</p><h2 id="encryption-and-signatures" tabindex="-1">Encryption and Signatures <a class="header-anchor" href="#encryption-and-signatures" aria-label="Permalink to &quot;Encryption and Signatures&quot;">​</a></h2><p>Public key cryptography allows individuals to send encrypted messages and data that can only be deciphered by the intended recipient possessing their corresponding private key. In other words, the public key functions as a lock, and the private key serves as an actual unique key that unlocks the encrypted data.</p><p>This encryption process not only ensures the privacy and confidentiality of sensitive information but also establishes the authenticity of the sender. By combining the sender&#39;s private key with the public key, a digital <em>signature</em> is created. This signature serves as a digital stamp of approval, verifying the sender&#39;s identity and the validity of the transferred data. Anyone with your <em>public</em> key can verify that the person who initiated the transaction used your <em>private</em> key.</p><h2 id="keys-on-the-client-side" tabindex="-1">Keys on the Client Side <a class="header-anchor" href="#keys-on-the-client-side" aria-label="Permalink to &quot;Keys on the Client Side&quot;">​</a></h2><p>Since every transaction must be signed on behalf of a peer, every operation requires a private key that is kept secret (hence the name). Therefore, the client program must handle both the storage and secure signing of transactions.</p><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>All clients are different, but <code>iroha</code> binary is the least secure in this regard, as it stores a peer&#39;s private key in the <code>multihash</code> format saved to a plain text file that could be overridden with an environment variable.</p><p><strong>This is currently a reference implementation that will <em>not</em> be a part of the production release.</strong></p></div><p>One needs to register a user on behalf of another already registered user (just like you need to already have a pair of scissors to cut off the tag from a new one). Suppose that we want to register a user on behalf of <code>mad_hatter@wonderland</code>.</p><p>This entails generating a new private key, and sending its public key to the network so that said network can verify that it&#39;s indeed the trustworthy <code>mad_hatter@wonderland</code>, and not some impostor (e.g. <code>mad_hatter@wünderbar</code>). In this case, the client application must prompt you, the user, to provide a key pair and verify the authenticity of the transactions: belonging to <code>mad_hatter@wonderland</code> and having a signature derived from the appropriate public key.</p><p>For public key cryptography to work effectively, avoid re-using keys when you need to specify a new key. While there&#39;s nothing stopping you from doing that, the public keys are <em>public</em>, which means that if an attacker sees the same public key being used, they will know that the private keys are also identical.</p><p>Even though <em>private</em> keys operate on slightly different principles than passwords, the advice—<em>to make them as random as possible, never store them unencrypted and never share them with anyone under any circumstances</em>—applies.</p>',14),o=[n];function s(c,p,h,d,y,l){return a(),t("div",null,o)}const g=e(r,[["render",s]]);export{m as __pageData,g as default};
